# Clojure

## 클로저의 구조

### REPL(read-eval-print loop)

평가하고 결과를 사용자에게 반환하는 컴퓨터 프로그래밍 환경이다. 

클로저는 clj 로 실행한다.

**클로저 코드는 식으로 구성되며 그 식이 평가된 결과가 반환된다.**

```clojure
(/ 1 3.0)
 ; => 0.333333333
(연산자 인수1 인수2)
```

클로저에서는 함수나 연산자가 먼저 오고, 필요한 인수들이 뒤에온다.  

## 컬렉션

불변이고 존속적이다. 존속적이란 것은 이전 버전의 값이 지워지지 않고 보존됨(깃 처럼??)

### 리스트

순서가 있다.

괄호 앞에 ‘를 붙여서 만든다. 

문자열, 정수, 키워드 와 같은 여러 종류의 값을 혼합해서 넣을 수 있다.

```clojure
'(1 2 3 :key1 "test")
 ; => (1 2 :key1 "test")
```

### 벡터

[대괄호로 둘러 싸서 만든다]

리스트와 달리 nth last 사용시 바로 요소에 접근할 수 있다.

```clojure
(first [1 2 3 :key1 "test"])
 ; => 1
```

### 맵

{:맵은 “중괄호로” :둘러싸서 “만든다”}

get : 요소를 가저온다. keys : 키값들을 리스트로 반환한다. vals : 값들을 리스트로 반환한다. assoc : 맵에 새로운 키-값 쌍을 맵핑한다. dissoc: 해당 키-값 요소를 제거하고 남은 맵을 반환한다. 

```clojure
(get {:맵은 “중괄호로” :둘러싸서 “만든다”} :맵은)
 ; => 중괄호로
```

### 집합

#{} 중괄호로 둘러싸서 만든다.

유일한 값들이 존재, 중복 요소가 없다. 

```clojure
#{:a :b :c :d}
 ; => #{:a :b :c :d}
```

## 시퀀스 함수

> 클로저에서 쉼표는 무시된다. 컬랙션에서 요소들을 구분할 때는 가급적 공백문자를 사용하자.
> 

## 리스트는 클로저의 핵심이다.

클로저의 기본 구조인 리스트는 LISP 언어의 본질에서 유래한다. 

```clojure
‘(+ 11 11)
 ; => (+ 11 11)
;식을 세개의 요소를 가진 리스트로 인식한다. 
```
## 논리에 따른 흐름 제어

### 기본 논리

논리적으로 참 : true 

논리적으로 거짓 : false, ***nil***

### 논리제어 기본 함수

> *함수의 결과가 불린일 땐 함수의 이름 뒤에 ?를 붙이는 것이 관용적이다.*
> 

true? : 인자가 true 이면 true 

false? : 인자가 false 이면 false

nil? : 값이 없음을 검사한다.

not : Boolean 의 반대값을 반환
= : 인자가 서로 일치하는지를 검사한다.

not= : 일치하지않는지를 검사하다.

> *nil은 논리적으로 거짓이다.*
> 

클로저 코드를 제어하는 법을 알아볼 것이다.

# 논리적 흐름 제어

## 일반 논리연산

true?  : true 값인지 검사한다.

false? : 인자가 false 값이면 true를 리턴하고 그 외의 경우 false

```clojure
(false? false) ;=> **true** 
(false? true) ;=> false
(false? nil) ;=> false 
(false? "foo") ;=> false
```

not     :  인자가 논리적으로 false 라면 true를 리턴하고 그 외의 경우 false 

```clojure
(not false) ;=> **true**
(not true) ;=> false
(not nil) ;=> **true** 
(not "foo") ;=> false
```

nil?     :  인자가 nil이면 ture를 리턴하고 그 외의 경우 false

```clojure
(nil? false) ;=> false
(nil? true) ;=> false
(nil? nil) ;=> **true**
(nil? "foo") ;=> false
```

![함수 not, false?, nil? 이 true 를 리턴하는 경우 비교  ](## 논리에 따른 흐름 제어

### 기본 논리

논리적으로 참 : true 

논리적으로 거짓 : false, ***nil***

### 논리제어 기본 함수

> *함수의 결과가 불린일 땐 함수의 이름 뒤에 ?를 붙이는 것이 관용적이다.*
> 

true? : 인자가 true 이면 true 

false? : 인자가 false 이면 false

nil? : 값이 없음을 검사한다.

not : Boolean 의 반대값을 반환
= : 인자가 서로 일치하는지를 검사한다.

not= : 일치하지않는지를 검사하다.

> *nil은 논리적으로 거짓이다.*
> 

클로저 코드를 제어하는 법을 알아볼 것이다.

# 논리적 흐름 제어

## 일반 논리연산

true?  : true 값인지 검사한다.

false? : 인자가 false 값이면 true를 리턴하고 그 외의 경우 false

```clojure
(false? false) ;=> **true** 
(false? true) ;=> false
(false? nil) ;=> false 
(false? "foo") ;=> false
```

not     :  인자가 논리적으로 false 라면 true를 리턴하고 그 외의 경우 false 

```clojure
(not false) ;=> **true**
(not true) ;=> false
(not nil) ;=> **true** 
(not "foo") ;=> false
```

nil?     :  인자가 nil이면 ture를 리턴하고 그 외의 경우 false

```clojure
(nil? false) ;=> false
(nil? true) ;=> false
(nil? nil) ;=> **true**
(nil? "foo") ;=> false
```

![함수 not, false?, nil? 이 true 를 리턴하는 경우 비교  ](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ae1dd161-a84e-4d46-bd50-9c94e8c8dd61/Untitled.png)

함수 not, false?, nil? 이 true 를 리턴하는 경우 비교  

## 비교

= 동등임을 아님을 검사한다.

not= 동등이 아님을 검사한다.

## 컬렉션에 사용하는는 논리 검사

empty? 컬렉션이 비었는지 확인할 수 있다. 비었으면 true 요소 있으면 true

seq 컬렉션을 시퀀스로 바꿔준다. 컬렉션을 리스트처럼 순차적으로 다룰 수 있게 해준다. (first rest cons 함수를 공유한다. ) 빈 컬렉션이면 nil 반환

> 벡터인데 어떻게 first 되지? 에 대한 답변 제공
> 

비어있지 않음을 검사하기 위해 사용됨.

진위검사

기본적 제어구문

### 컬렉션 요소 검사

every?

not-any? 하나라도 참이면 false 한번이라도 담배를 베트남에 다녀왔다면 헌혈을 할수 없다.

some 한번이라도 참을 만나면 true 반환

cf) 집합도 함수의 존재 여부 확인에 활용 가능

(#{1 2 3 4} 2)

2

논리적 거짓이 존재하는지 some 을이용해버리면 nil - false 가리턴 되니 조심

> 대신 어떤것을 사용해야할까? nil? false?
> 

some false? 사용하거나 

### 흐름제어 이용하기.

(if (논리) (참일때 평가) (false시 평가))

if  논리 검사식 참이면 두번째 인수 아니면 세번째 인수

if-let

식을 평가한 결과를 심볼에 바인딩 (검사식의 결과를 심볼에 바인딩 시 유용)

결과가 참이면 첫번째, 아니면 세번째 인수 평가

when : if 와 달리 참일때만 평가 하고싶을 때

when-let : 논리검사 결과를 심볼에 바인딩, 참 > true 아니면 nil

cond : 조건식을 여러개 쓰고 싶을때 사용, 한 검사가 참이 나오면 해당 식이 평가되고 이후 절들은 무시되기 때문에 검사의 순서가 중요하다.

:else 로 디폴트 절을 추가할 수 있다.

cond 상황에서 특정 상황 (검사할 심볼이 같고, =로 비교하는 경우) case 사용 가능하다.

case 마지막은

#2. 구조분해 : 컬렉션의 요소 중 관심 대상인 요소를 뽑아내어 이름을 부여

#3. 지연평가 (feat. 재귀)

#4. 데이터 조작 함수)

함수 not, false?, nil? 이 true 를 리턴하는 경우 비교  

## 비교

= 동등임을 아님을 검사한다.

not= 동등이 아님을 검사한다.

## 컬렉션에 사용하는는 논리 검사

empty? 컬렉션이 비었는지 확인할 수 있다. 비었으면 true 요소 있으면 true

seq 컬렉션을 시퀀스로 바꿔준다. 컬렉션을 리스트처럼 순차적으로 다룰 수 있게 해준다. (first rest cons 함수를 공유한다. ) 빈 컬렉션이면 nil 반환

> 벡터인데 어떻게 first 되지? 에 대한 답변 제공
> 

비어있지 않음을 검사하기 위해 사용됨.

진위검사

기본적 제어구문

### 컬렉션 요소 검사

every?

not-any? 하나라도 참이면 false 한번이라도 담배를 베트남에 다녀왔다면 헌혈을 할수 없다.

some 한번이라도 참을 만나면 true 반환

cf) 집합도 함수의 존재 여부 확인에 활용 가능

(#{1 2 3 4} 2)

2

논리적 거짓이 존재하는지 some 을이용해버리면 nil - false 가리턴 되니 조심

> 대신 어떤것을 사용해야할까? nil? false?
> 

some false? 사용하거나 

### 흐름제어 이용하기.

(if (논리) (참일때 평가) (false시 평가))

if  논리 검사식 참이면 두번째 인수 아니면 세번째 인수

if-let

식을 평가한 결과를 심볼에 바인딩 (검사식의 결과를 심볼에 바인딩 시 유용)

결과가 참이면 첫번째, 아니면 세번째 인수 평가

when : if 와 달리 참일때만 평가 하고싶을 때

when-let : 논리검사 결과를 심볼에 바인딩, 참 > true 아니면 nil

cond : 조건식을 여러개 쓰고 싶을때 사용, 한 검사가 참이 나오면 해당 식이 평가되고 이후 절들은 무시되기 때문에 검사의 순서가 중요하다.

:else 로 디폴트 절을 추가할 수 있다.

cond 상황에서 특정 상황 (검사할 심볼이 같고, =로 비교하는 경우) case 사용 가능하다.

case 마지막은

#2. 구조분해 : 컬렉션의 요소 중 관심 대상인 요소를 뽑아내어 이름을 부여

#3. 지연평가 (feat. 재귀)

#4. 데이터 조작 함수
