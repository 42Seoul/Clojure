# Clojure

## 클로저의 구조

### REPL(read-eval-print loop)

평가하고 결과를 사용자에게 반환하는 컴퓨터 프로그래밍 환경이다. 

클로저는 clj 로 실행한다.

**클로저 코드는 식으로 구성되며 그 식이 평가된 결과가 반환된다.**

```clojure
(/ 1 3.0)
 ; => 0.333333333
(연산자 인수1 인수2)
```

클로저에서는 함수나 연산자가 먼저 오고, 필요한 인수들이 뒤에온다.  

## 컬렉션

불변이고 존속적이다. 존속적이란 것은 이전 버전의 값이 지워지지 않고 보존됨(깃 처럼??)

### 리스트

순서가 있다.

괄호 앞에 ‘를 붙여서 만든다. 

문자열, 정수, 키워드 와 같은 여러 종류의 값을 혼합해서 넣을 수 있다.

```clojure
'(1 2 3 :key1 "test")
 ; => (1 2 :key1 "test")
```

### 벡터

[대괄호로 둘러 싸서 만든다]

리스트와 달리 nth last 사용시 바로 요소에 접근할 수 있다.

```clojure
(first [1 2 3 :key1 "test"])
 ; => 1
```

### 맵

{:맵은 “중괄호로” :둘러싸서 “만든다”}

get : 요소를 가저온다. keys : 키값들을 리스트로 반환한다. vals : 값들을 리스트로 반환한다. assoc : 맵에 새로운 키-값 쌍을 맵핑한다. dissoc: 해당 키-값 요소를 제거하고 남은 맵을 반환한다. 

```clojure
(get {:맵은 “중괄호로” :둘러싸서 “만든다”} :맵은)
 ; => 중괄호로
```

### 집합

#{} 중괄호로 둘러싸서 만든다.

유일한 값들이 존재, 중복 요소가 없다. 

```clojure
#{:a :b :c :d}
 ; => #{:a :b :c :d}
```

## 시퀀스 함수

> 클로저에서 쉼표는 무시된다. 컬랙션에서 요소들을 구분할 때는 가급적 공백문자를 사용하자.
> 

## 리스트는 클로저의 핵심이다.

클로저의 기본 구조인 리스트는 LISP 언어의 본질에서 유래한다. 

```clojure
‘(+ 11 11)
 ; => (+ 11 11)
;식을 세개의 요소를 가진 리스트로 인식한다. 
```
